# FileProcess 과제 1
1. 개요 
아래의 기능들을 각각 수행하는 프로그램을 구현한다. 구현할 때 다음과 같은 제약 사항들을 따른다.
- 파일의 데이터는 아라비아 숫자와 영어 알파벳만으로 표현되며, 사용자 입력으로 주어지는 데이터도 이 조건을 따른다.
- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.

(1) 복사: copy.c 작성
원본파일명과 복사본파일명을 표준입력으로 줄 때 복사본파일을 생성하고 원본파일로부터 100바이트 단위로 데이터를 읽어 복사본파일에 저장한다.
    
a.out <원본파일명> <복사본파일명>

(2) 읽기: read.c 작성
파일에서 주어진 오프셋(offset = 0, 1, 2, ...)으로부터 오른쪽에 존재하는, 주어진 <읽기 바이트 수>만큼의 데이터를 읽어서 화면에 출력한다. 만약 주어진 <읽기 바이트 수>만큼의 데이터가 존재하지 않으면 오프셋부터 파일의 맨마지막 바이트(EOF 제외)까지 읽어서 출력한다.

a.out <파일명> <오프셋> <읽기 바이트 수>

(3) 병합하기(merge): merge.c 작성
주어진 두 개의 파일들을 병합하며, 병합하는 순서는 주어진 파일 순서와 동일하다.

a.out <파일명1> <파일명2>

(4) 덮어쓰기(overwrite): overwrite.c 작성
주어진 오프셋 위치에서부터 데이터를 덮어쓴다. 덮어쓰기를 할 때 파일의 EOF를 만나면 중단하지 않고 그대로 쓰기를 진행한다. 즉 주어진 데이터가 오프셋에서부터 그대로 저장되어야 한다.

a.out <파일명> <오프셋> <데이터>

(5) 끼워넣기(insert): insert.c 작성
파일에서 주어진 오프셋에 데이터를 끼워 넣는다. 만약 주어진 오프셋이 5라면 끼워넣는 데이터의 첫 번째 바이트는 오프셋 5에 저장된다.

a.out <파일명> <오프셋> <데이터>
(6) 삭제하기(delete): delete.c 작성
주어진 오프셋 위치에서부터 오른쪽에 존재하는, 주어진 <삭제 바이트 수>만큼의 데이터를 파일에서 삭제한다. 만약 <삭제 바이트 수>만큼의 데이터가 존재하지 않는 경우 파일의 마지막 바이트까지 삭제한다. 삭제하고 난 후 삭제 데이터를 기준으로 전후 데이터가 병합되어야 한다. 즉, 삭제 데이터의 공간은 파일에서 사라져야 한다.

a.out <파일명> <오프셋> <삭제 바이트 수>

# FileProcess 과제 2
1. 개요 

강의자료 Chap3의 15쪽에서 배운 순차 읽기와 랜텀 읽기에 대한 두 가지 프로그램을 구현하며, 다음과 같은 제약 사항을 따른다.
- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.

(1) ‘학생’ 레코드가 100바이트라고 가정할 때 아래 (2)과 (3)에서 사용할 학생 레코드 파일을 준비한다. 레코드의 데이터는 굳이 신경쓰지 않아도 되며, 레코드 파일에는 n 개의 학생 레코드가 저장되며 n은 비교적 큰 수(>1000)이며, 자유롭게 선택해서 사용한다 (당연히 레코드 파일의 크기는 n*100바이트가 되어야 함).

(2) 주어진 레코드 파일에 저장되어 있는 n 개의 레코드를 순차적으로(sequential) 사용자 프로그램 상으로 읽어 들이는 프로그램을 구현한다 (즉, read_seq.c를 완성). 또한, 이때 걸리는 시간을 측정하는 코드를 추가한다 (예를 들면, gettimeofday() 함수 등을 사용).

(3) 주어진 레코드 파일에 저장되어 있는 모든 레코드를 랜덤(random)하게 읽어 들이는 프로그램을 구현한다 (즉, read_random.c를 완성). 또한, 이때 걸리는 시간을 측정하는 코드를 프로그램에 추가한다.

2. 입력

- read_seq.c: 레코드 파일명을 표준입력으로 읽어 들이고(예: sread record_file1), 이 파일에 저장되어 있는 레코드의 개수를 간단히 계산하고 그 개수를 순차적 레코드 읽기에 사용한다. 이때 레코드 파일에는 100바이트짜리 학생 레코드가 정확히 정수 개만큼 저장되어 있어야 한다.
- read_rand.c: 레코드 파일명을 표준입력으로 읽어 들이고(예: rread record_file2), 이 파일에 저장되어 있는 레코드의 개수를 간단히 계산하고 그 개수를 무작위 레코드 읽기에 사용한다. 이때 레코드 파일에는 100바이트짜리 학생 레코드가 정확히 정수 개만큼 저장되어 있어야 한다.

<주의사항>
- 명령어에 인자로 주어지는 레코드 파일은 실행 디렉토리에 존재해야 함
- 입력 포맷을 반드시 지켜야 하며, 그렇지 않을 경우 채점 프로그램에 오류가 발생하며 0점 처리됨
  
3. 출력
 
출력은 표준출력으로 하며, 구현한 명령어를 수행시킬 때 주어진 레코드 파일에 저장되어 있는 전체 레코드의 개수와 전체 레코드를 각각의 방식으로 모두 읽을 때 걸리는 시간을  다음과 같은 예시로 출력하여야 한다 (아래는 예시일 뿐 실제적으로는 다른 값이 출력될 수 있음). 아래에서 #records는 전체 레코드의 수를, timecost는 전체 레코드를 읽을 때 걸리는 시간을 나타낸다.

$ ./sread s1.dat
#records: 1000 timecost: 2300 us
$ ./rread s2.dat
#records: 1000 timecost: 9300000 us

# FileProcess 과제 3

1. 개요 

“Flash Memory” 강의에서 배운 Flash device driver에 대한 이해를 높이고 이를 활용하는 프로그램을 구현하며, 다음과 같은 제약 사항을 따라야 한다.

- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
-아래의 (1), (2), (3), (4)의 기능을 ftlmgr.c에 구현한다.
-아래 (2), (3), (4)의 기능은 fdevicedriver.c의 인터페이스를 이용하여 구현한다.
-fdevicedriver.c는 주어진 그대로 사용하며 수정해서는 안된다.

(1) flash memory emulator
Flash memory 저장 장치를 모방하는 flash memory 파일을 생성한다. 여기에는 n 개의 블록과 각 블록에 m 개의 페이지가 존재하며, 각 페이지는 하나의 512B 섹터영역과 16B 스페어영역(spare area)으로 구성된다고 가정한다. 또한 블록은 4 개의 페이지로 구성되어 있다라고 가정한다 (즉, m=4). 아래의 명령어를 실행시키면 블록의 수 <#blocks>로 구성되는 flash memory 파일 <flashfile>을 생성한다. 

a.out c <flashfile> <#blocks>

<예시>
a.out c flashmemory 100

옵션으로 c를 사용하며, 100 개의 블록과 각 블록은 4 개의 페이지로 구성되는 flashmemory 파일을 생성한다 (파일 크기: 100*4*(512+16)=211,200B). 이때 모든 블록의 각 바이트는 0xFF로 초기화한다 (파일 전체를 0xFF로 채운다). Flash memory에서 ‘erase’ 연산도 결국 초기화 작업이기 때문에 파일에서 0xFF로 초기화하는 방법은 fdevicedriver.c의 dd_erase() 함수를 참고하여 프로그래밍한다.

<주의>
- 생성한 flash memory 파일은 아래 (2), (3), (4)에서 사용한다.

(2) 페이지 쓰기
Flash memory 저장장치에 페이지 단위로 데이터 쓰기를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <ppn>의 물리적 페이지 번호를 가지는 페이지에, 섹터영역에는 <sectordata>를 스페어영역에는 <sparedata>를 저장한다. 만약 <flashfile>의 블록의 수가 100이고 페이지 수가 4이면 ppn=0, 1, 2, ..., 399가 된다. <sectordata>와 <sparedata>는 각각 512B와 16B가 되어야 하나 그렇지 않아도 무방하다. 화면에 실행 결과를 출력할 필요가 없다.

a.out w <flashfile> <ppn> <sectordata> <sparedata>

<예시>
a.out w flashmemory 15 “abcd12345@%$” “5”

옵션으로 w를 사용하며, ppn=15 즉, 16 번째 페이지에 큰따옴표로 묶여있는 abcd12345@%$를 저장한다. 주어진 flashmemory 파일은 이미 생성되어 있어야 하며, 이 파일에는 최소한 16 개 이상의 페이지가 존재해야 한다. 주어진 섹터데이터를 해당 페이지에 처음부터 차례로 저장한다. 만약 주어진 섹터데이터가 512B보다 적을 경우 나머지 공간은 0xFF로 채운다. abcd12345@%$를 16 번째 페이지에 처음부터 채우고 나머지 500B는 0xFF로 채운다. 스페어의 경우도 이와 같은 방식으로 처리한다.

<주의>
- <sectordata>와 <sparedata>는 blank를 포함할 수 있기 때문에 큰따옴표로 데이터를 묶어서 입력한다. 그렇지 않는 경우 채점 시 정상적으로 동작하지 않는다.
-섹터 데이터와 스페어 데이터는 키보드로 입력할 수 있는 문자로 표현한다.
- 같은 페이지에 여러 번 쓰기 연산을 수행시킬 수 있다 (즉 갱신).

(3) 페이지 읽기
Flash memory 저장장치에서 페이지 단위로 페이지 읽기를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <ppn>의 물리적 페이지 번호를 가지는 페이지에 저장되어 있는 섹터 데이터와 스페어 데이터를 화면에 출력한다.

a.out r <flashfile> <ppn>

<예시>
a.out r flashmemory 15
abcd12345@%$ 5

옵션으로 r를 사용하며, flashmemory 파일의 ppn=15 페이지에서 섹터영역의 데이터와 스페어영역의 데이터를 읽어서 화면에 출력한다. 위의 (2)의 예시와 같이 데이터를 저장하였다고 가정한 것이며, 섹터 데이터와 스페어 데이터는 각각 첫 번째 0xFF 전까지의 의미있는 데이터만을 출력한다.

<주의>
- 읽어야 할 페이지에 의미있는 데이터가 존재하지 않는 경우 (섹터와 스페어에 0xFF만 저장되어 있는 경우) 화면에 출력할 필요가 없다.

(4) 블록 소거(erase)
Flash memory 저장장치에서 블록 단위로 블록 소거를 수행한다. 아래 명령어를 실행시키면 <flashfile> 파일의 <pbn>의 물리적 블록번호를 가지는 블록을 소거한다. 화면에 실행 결과를 출력할 필요가 없다.

a.out e <flashfile> <pbn>

<예시>
a.out e flashmemory 3

옵션 e를 사용하며, flashmemory 파일의 pbn=3 즉, 4 번째 블록을 소거한다. 

# FileProcess 과제 4

1. 개요 

Sector mapping 기법(강의자료 “Flash Memory Overview”의 19쪽)을 따르는 FTL을 구현한다. 다음과 같은 제약 사항을 따라야 한다.

- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
-아래의 (1), (2), (3), (4)의 기능을 ftlmgr.c에 구현한다.
-sectormap.h와 fdevicedriver.c는 주어진 그대로 사용하며 수정해서는 안된다.
-네 개의 함수를 테스트하기 위해 main() 함수를 본인 스스로 만들기 바라며, file system의 역할을 수행하는 main() 함수에서의 대략적인 시나리오는 (1) flash memory file 생성 및 초기화(과제3에서 수행) (2) ftl_open() 호출 (3) ftl_write()나 ftl_read() 호출하여 테스트하는 것으로 이루어진다. 테스트 프로그램을 실행하기 전에 이전에 사용했던 flash memory file은 삭제해야 한다.

(1) ftl_open() 구현

일반적으로 FTL을 구현하기 위해서는 논리주소를 물리주소를 변환하는 address mapping table이 필요하다. Sector mapping FTL에 맞는 address mapping table을 생각해 보고 이에 맞는 data structure를 정의해서 사용한다 (강의자료 참조). 이러한 data structure를 이용하여 address mapping table을 하나 생성한다 (즉, 변수 선언).

ftl_open()에서는 일반적으로 여러 초기화 작업을 하는데, 예를 들면, 생성한 address mapping table에서 lpn에 매핑되는 ppn의 값을 –1로 초기화를 한다. ftl_open()이 호출되는 시점은 flash memory를 최초로 사용하는 때이다. 따라서 file system의 어떤 lbn도 사용되지 않았으며 당연히 lbn에 매핑되는 pbn도 존재하지 않는다. 그런 의미에서 –1로 설정하는 것이다.

그 이외에 초기화할 작업이 필요한 경우가 존재한다면 이 함수에서 수행한다.

**file system에서 ftl_write()나 ftl_read()를 최초로 호출하기 전에 반드시 ftl_open()를 호출해야 한다.

(2) ftl_write(int lsn, char *sectorbuf) 구현

File system이 ftl_write()를 호출할 때 인자값으로 lsn(=lpn)과 sectorbuf에 저장되어 있는 512B 데이터를 전달한다. FTL은 이 데이터를 flash memory에 쓰기를 해야 하는데, 이때 어떤 물리적 페이지(ppn)에 써야할 지를 결정해야 한다. 이것은 sector mapping 기법의 동작 원리대로 결정되어야 한다. 예를 들면, file system이 ftl_write(lsn=5, sectorbuf)를 호출하면 sector mapping FTL은 address mapping table의 lpn=5를 찾고 이것에 매핑되는 ppn값을 확인한다. 만약 ppn=-1이라면 file system은 lpn=5 위치에 최초로 쓰기 작업을 수행한다는 것을 의미한다. 그렇지 않는 경우라면 file system은 lpn=5 위치에 이미 존재하는 데이터를 갱신(update)를 하기를 원한다는 것을 의미한다. 두 경우 모두, sector mapping FTL은 비어있는 ppn 중에서 하나를 선택해서 그 값으로 address mapping table의 해당 ppn을 갱신한다. 즉, lpn=5에 매핑되는 ppn 값으로 저장한다. File system이 이 함수를 호출할 때 lpn 위치에 최초 쓰기를 하는지 아니면 덮어 쓰기(overwrite)를 하는지 체크하는 과정이 필요하다.

비어있는 ppn을 할당한 후, FTL은 ppn이 가리키는 flash memory의 페이지에 쓰기 연산을 수행한다. 이때 flash device driver의 dd_write() 함수를 호출한다(과제 3 참고). FTL이 쓰기 연산을 할 때는 sector 단위가 아니라 page 단위임을 주의해야 한다. Flash device driver의 dd_write(int ppn, char *pagebuf)를 호출하기 전에 pagebuf에 file system으로부터 받은 sector 데이터와 lsn(lpn)을 각각 sector 영역과 spare 영역에 저장하고 이 pagebuf를 인자값으로 전달한다. 여기서 lpn을 spare에 저장하는 이유는 ppn이 lpn에 매핑되어 있다는 것을 표현하기 위한 것이다.

File system이 계속 쓰기 요청을 하면 결국 비어있는 ppn이 남아 있지 않는 상황이 발생할 수 있다. 이런 경우 flash memory에서 garbage 블록을 선정해서 빈 ppn을 만들어 낼 수 있다. 이때 예비 블록으로 남겨 둔 free block을 활용한다. garbage 블록의 선정을 위해 각자 본인의 알고리즘을 생각해 보기 바라며, 또한 garbage 블록의 빠른 선정을 위해 garbage 블록을 어떻게 관리하는 게 좋을지도 생각해 보기 바란다 (예를 들면, linked list). 참고로 garbage block은 새로운 free block이 되기 때문에 free block의 pbn은 바뀔 수 있다.

** dd_write()를 호출하기 전에 pagebuf에 sector 데이터와 spare 데이터를 저장할 때 memcpy()를 쓰면 편리하며 물론 다른 방식을 사용해도 됨

(3) ftl_read(int lsn, char *sectorbuf) 구현

File system이 ftl_read()를 호출할 때 인자값으로 lsn(=lpn)과 flash memorydml 512B 데이터를 저장할 sectorbuf를 인자값으로 전달한다. FTL은 address mapping table에서 주어진 lsn에 매핑되어 있는 ppn값을 구하고, 이것이 가리키는 flash memory의 페이지를 읽는다. 이때 flash device driver의 dd_read() 함수를 호출한다. 그리고 읽어 온 페이지에서 sector 영역에 저장되어 있는 데이터를 file system이 인자로 제공한 sectorbuf에 저장하여 전달한다.

** dd_read()를 통해 flash memory에서 페이지를 읽어 온 후 file system에 그 페이지의 sector 데이터를 전달하기 전에 sectorbuf에 저장해야 하는데 이때도 memcpy()를 사용하면 편리함

(4) ftl_print() 구현

일반적으로 FTL이 제공해야 할 함수는 ftl_open(), ftl_write(), ftl_read() 세 개뿐이며, 이 함수는 단지 FTL의 address mapping table을 확인하기 위한 용도로 사용하기 위한 것이다. 이 함수는 화면에 lpn, ppn, free block의 pbn을 다음과 같이 출력해야 한다.
(flash memory의 가용 블록 수가 3, 블록당 페이지 수가 4이고, 이 함수를 호출하는 시점에서 free block의 pbn=3라고 가정한다)

lpn ppn
0   -1
1   -1
2   -1
3   -1
4   2
5   3
6   4
7   5
8   0
9   1
10  -1
11  -1
free block’s pbn=3

# FileProcess 과제 5
1. 개요 

Chap6의 레코드 삭제 관리 및 재사용에 관한 프로그램을 작성한다. 아래의 조건을 반드시 준수하여야 한다.

- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
-제공되는 person.h와 person.c를 이용하여 아래의 (2) (3)의 기능을 완성한다.

(1) ‘Person’ 레코드 파일의 구조
-레코드 파일은 페이지(page) 단위로 저장되며 여러 개의 페이지들로 구성된다. 첫 번째 페이지는 헤더(header)의 역할을 수행하며(헤더 페이지), 그 이후 페이지는 ‘Person’ 레코드를 저장하는데 사용된다(데이터 페이지). 페이지 번호는 헤더 페이지부터 0, 1, 2, ...을 부여한다.
-헤더 페이지는 세 종류의 정보를 저장하며, 첫 4바이트에는 레코드 파일을 구성하는 전체 페이지 수(헤더 페이지 포함)를, 그 다음 4바이트에는 레코드 파일에 존재하는 모든 레코드(삭제 레코드 포함)의 수를, 그 다음 8바이트에는 페이지 번호와 레코드 번호를 각각 4바이트씩 할당하여 저장한다. 페이지 번호와 레코드 번호는 삭제 레코드 리스트를 관리할 때 사용하며, 항상 가장 최근에 삭제된 레코드를 가리킨다. 페이지 번호와 레코드 번호의 초기값은 각각 –1이며, 삭제 레코드가 더 이상 존재하지 않을 경우에도 각각 –1의 값을 가진다. 헤더 페이지의 두 종류의 데이터는 항상 최신의 정보로 유지해야 한다. 헤더 페이지는 첫 번째 레코드가 저장될 때 처음으로 생성된다.
-데이터 페이지에는 ‘Person’ 레코드가 저장되며, 레코드를 저장할 때 페이지에 공간이 부족하면 새로운 데이터 페이지를 할당 받아서 그 레코드를 저장한다 (두 페이지에 걸쳐서 레코드를 저장하지 않는다). 물론, 전체 레코드 파일에 삭제 레코드가 존재하면 삭제 레코드 공간에 우선적으로 저장해야 한다. 그렇지 않으면 맨 마지막 데이터 페이지에 저장한다.
-‘Person’ 레코드는 fixed length record 방식으로 저장되며, 각 필드는 구분자(delimiter) 방식으로 서로 구분한다. 레코드를 하나 저장할 때마다 데이터 페이지에 RECORD_SIZE(=100B)만큼의 공간이 할당되며, 이 공간의 맨 앞쪽부터 데이터를 저장해 나간다. 구분자는 #를 사용한다. 어떤 경우에는 할당된 RECORD_SIZE의 공간을 다 사용하지 못하는 경우도 있지만, fixed length record 방식이므로 모든 레코드의 공간은 항상 RECORD_SIZE의 크기를 갖는다.
-아래 그림의 레코드 파일은 헤더 페이지와 두 개의 데이터 페이지로 구성되어 있으며, 전체 레코드(삭제 레코드 포함)는 9 개, 삭제 레코드는 3 개를 갖고 있다. 삭제 레코드는 linked list로 관리되며, 가장 최근에 삭제된 레코드는 (2, 0)가 가리키는 곳에 위치하며 화살표의 역방향 순서대로 삭제가 이루어졌음을 알 수 있다.
 
(1) 레코드 삽입(insert)
-터미널에서 person 정보를 입력받고 이를 레코드 파일에 저장한다. 먼저 삭제 레코드가 존재하는지 확인한 후 만약 삭제 레코드가 존재하면 가장 최근에 삭제된 레코드 공간에 새로운 레코드를 저장하며, 그렇지 않은 경우 맨 마지막 데이터 페이지에 append 형식으로 저장한다. 당연히 필요한 경우, 헤더 페이지의 정보와 삭제 레코드 리스트 등을 수정한다. 참고로, 헤더 페이지의 전체 레코드의 수는 정상적인 레코드와 삭제 레코드의 수의 합이다.
-삭제 레코드의 공간을 할당할 때 삭제 레코드 리스트에서 가장 최근에 삭제된 레코드를 선택한다.
-Person 정보는 6 개의 필드로 구성되며, 사용자는 주민번호, 이름, 나이, 주소, 전화번호, 이메일주소 순서대로 필드값을 입력한다. 필드값은 큰따옴표로 묶어서 입력하며, 필드값은 영문자, 숫자, 특수문자(-, @ 등)만으로 구성된다고 가정한다. 

a.out i <record file name><field values list>

<예시>
a.out i person.dat “8811032129018” “GD Hong” “23” “Seoul” “02-820-0924” “gdhong@ssu.ac.kr”

옵션으로 i를 사용하며 입력받은 필드값을 packing한 후, 즉 8811032129018#GD Hong#23#Seoul#02-820-0924#gdhong@ssu.ac.kr# 형태를 만들어서 이것을 person.dat 레코드 파일에 저장한다. 명령의 수행 후 출력은 없다.

** 주의: 나이를 포함한 모든 필드값은 문자열로 레코드에 저장한다. 하지만 헤더 페이지와 삭제 레코드에서의 모든 메타 데이터는 이진 정수(binary integer)로 저장한다.

(2) 레코드 삭제(delete)
-터미널에서 person 정보 중 주민번호를 입력받고 레코드 파일에서 이것과 일치하는 레코드가 존재하면 해당 레코드를 삭제한다.
-삭제 레코드는 Chap6에서 배운 방식대로 관리한다. 삭제 레코드의 첫 번째 바이트는 delete mark *를, 그 다음 4바이트에는 페이지 번호를, 그 다음 4바이트에는 레코드 번호를 저장한다.
-페이지 방식으로 레코드를 저장하기 때문에 약간의 수정이 필요하다. Chap6에서는 liked list에서 ‘link’에 해당하는 값으로 바로 직전에 삭제된 레코드 번호를 사용하였으나 이 과제에서는 레코드 번호 대신에 (페이지 번호, 레코드 번호)의 조합을 사용하며, 여기서 페이지 번호는 바로 직전에 삭제된 레코드가 존재하는 페이지를, 레코드 번호는 이 페이지에서의 레코드 번호를 의미한다. 각 데이터 페이지에서의 레코드 번호는 0, 1, 2, ... 순서의 값을 가지며, 모든 데이터 페이지에서의 첫 번째 레코드 번호는 0이다.

a.out d <record file name> <field value>

<예제>
a.out d person.dat “8811032129018”

옵션은 d를 사용하며, person.dat 레코드 파일에서 주민번호 8811032129018과 일치하는 레코드를 찾아서 삭제한다. 명령의 수행 결과에 대한 출력은 없다.

# FileProcess 과제 6

1. 개요 

Chap8의 heap sorting 프로그램을 작성한다. 아래의 조건을 반드시 준수하여야 한다.

- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
-제공되는 person.h와 heapsort.c를 이용하여 아래의 기능 (3)을 완성한다.

(1) ‘Person’ 레코드 파일의 구조
-Heap sort를 위해 주어지는 입력 레코드 파일의 구조는 지난 과제 5에서 사용한 파일 구조와 동일하다.
-Heap sort에 의해 새로 생성되는 정렬된 레코드 파일의 구조도 과제 5와 동일하다.

(2) 입력 레코드 파일
-Heap sort를 하기 위해서는 미리 만들어진 레코드 파일이 필요하다. 이를 위해 지난 과제 5에서 만든 ‘레코드 삽입’ 기능을 수행하여 ‘n’ 개의 레코드를 갖는 레코드 파일을 생성하여 입력 레코드 파일로 사용한다. Heap sort에서 정렬의 기준은 주민번호이기 때문에 레코드 삽입 명령어를 수행할 때 입력되는 필드값들 중 주민번호만 중복이 되지 않게 제공해도 무방하다.
-과제 6에서는 과제 5에서 만든 ‘레코드 삭제’ 기능을 사용하지 않는다.

(3) Heap sort
-두 종류의 heap 중 Chap8의 heap을 가정한다 (heap의 루트 노도의 킷값이 가장 작다).
-Heap sort는 insert sort의 한 종류이기 때문에 정렬 프로그램에 레코드 파일이 모든 레코드를 저장할 수 있는 메모리 공간이 필요하다. 이러한 공간을 위해 Chap8에서 제시한 ‘배열’을 사용한다.
-정렬 프로그램으로 레코드를 읽어 들일 때는 과제 5와 같이 페이지 단위로 읽고, 읽어 온 페이지에 존재하는 레코드를 하나씩 heap에 추가하여 heap을 만들어 나간다. 읽어 온 페이지에서 모든 레코드를 처리하면 그 다음 페이지를 읽어서 위와 같은 방식으로 처리한다.
-완성한 heap을 이용하여 ‘주민번호’를 기준으로 오름차순으로 정렬된 새로운 레코드 파일을 만든다. 레코드를 새로운 파일에 저장할 때도 페이지 단위를 사용한다. 페이지를 하나 할당을 받은 후 여기에 레코드를 채운 후 페이지가 다 차면 파일에 쓰기를 수행한다.

a.out s <input record file name><output record file name>

<예시>
a.out s person.dat sortedperson.dat

옵션으로 s를 사용하며 레코드 파일 person.dat를 주민번호를 기준으로 오름차순으로 정렬된 sortedperson.dat를 생성한다. 명령의 수행 후 출력은 없다.

